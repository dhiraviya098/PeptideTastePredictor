import streamlit as st
import pandas as pd
import numpy as np
from modlamp.descriptors import GlobalDescriptor, PeptideDescriptor
from modlamp.properties import PeptideProperties
from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score, classification_report, confusion_matrix
import matplotlib.pyplot as plt
import seaborn as sns
import joblib
import os

# For structure
import py3Dmol
from Bio.PDB import PDBIO
from Bio.PDB.StructureBuilder import StructureBuilder
from Bio.PDB.Polypeptide import one_to_three

# -----------------------------
# Streamlit page setup
# -----------------------------
st.set_page_config(page_title="Peptide Taste Predictor", layout="wide")

st.title("ðŸ¥¼ Peptide Taste Prediction App")
st.write("Predict peptide **taste class** and view **basic structure & properties** from the amino acid sequence.")

# -----------------------------
# 1. Load Dataset
# -----------------------------
@st.cache_data
def load_data():
    df = pd.read_excel("AIML.xlsx")
    df.columns = df.columns.str.strip()
    return df

data = load_data()
st.subheader("Dataset Preview")
st.dataframe(data.head())

# -----------------------------
# 2. Feature Extraction
# -----------------------------
def compute_features(seq_list):
    """Compute biochemical descriptors using modlamp."""
    if not seq_list:
        return pd.DataFrame()
    try:
        gd = GlobalDescriptor(seq_list)
        gd.calculate_all()
        return pd.DataFrame(gd.descriptor)
    except Exception as e:
        st.error(f"Error computing features: {e}")
        return pd.DataFrame()

def compute_basic_properties(sequence):
    """Return dict of basic peptide properties."""
    try:
        props = PeptideProperties([sequence])
        mw = props.calculate_MW()[0]
        hydro = props.calculate_hydrophobicity()[0]
        charge = props.calculate_charge()[0]
        pI = props.calculate_isoelectric_point()[0]
        solubility_index = -hydro      # crude solubility proxy
        return {
            "Molecular Weight": round(mw, 2),
            "Hydrophobicity": round(hydro, 2),
            "Net Charge": round(charge, 2),
            "Isoelectric Point": round(pI, 2),
            "Solubility Index": round(solubility_index, 2)
        }
    except Exception as e:
        st.warning(f"Property calculation failed: {e}")
        return {}

# -----------------------------
# 3. Simple PDB generation for visualization
# -----------------------------
def peptide_to_pdb(seq, file_path="peptide.pdb"):
    builder = StructureBuilder()
    builder.init_structure("peptide")
    builder.init_model(0)
    builder.init_chain("A")
    builder.init_seg("    ")
    for i, aa in enumerate(seq, start=1):
        try:
            res = one_to_three(aa)
        except KeyError:
            continue
        builder.init_residue(res, " ", i, " ")
    io = PDBIO()
    io.set_structure(builder.get_structure())
    io.save(file_path)
    return file_path

def show_structure(seq):
    pdb_path = peptide_to_pdb(seq)
    with open(pdb_path, "r") as f:
        pdb_data = f.read()
    viewer = py3Dmol.view(width=500, height=400)
    viewer.addModel(pdb_data, "pdb")
    viewer.setStyle({'cartoon': {'color': 'spectrum'}})
    viewer.zoomTo()
    return viewer

# -----------------------------
# 4. Train / Load Model
# -----------------------------
MODEL_PATH = "taste_model.pkl"

@st.cache_resource
def train_model():
    X = compute_features(data["peptide"].tolist())
    y = data["Taste"]

    if X.empty:
        st.error("Feature computation failed or returned empty DataFrame.")
        return None, None, None, None, None

    counts = y.value_counts()
    valid_classes = counts[counts >= 2].index
    valid_idx = y[y.isin(valid_classes)].index
    X = X.loc[valid_idx]
    y = y[valid_idx]

    if len(y.unique()) < 2:
        st.error("Not enough classes with sufficient samples to train a model.")
        return None, None, None, None, None

    X_train, X_test, y_train, y_test = train_test_split(
        X, y, test_size=0.2, random_state=42, stratify=y
    )

    model = RandomForestClassifier(n_estimators=200, max_depth=20, random_state=42)
    model.fit(X_train, y_train)
    joblib.dump(model, MODEL_PATH)

    y_pred = model.predict(X_test)
    acc = accuracy_score(y_test, y_pred)
    report = classification_report(y_test, y_pred, output_dict=True)

    return model, X, y, acc, report

model, X, y, acc, report = train_model()

# -----------------------------
# 5. Display metrics
# -----------------------------
if model:
    if acc is not None:
        st.success(f"Model trained with accuracy: {acc:.2f}")
        st.write("Classification Report:", report)

        # Feature importance
        st.subheader("ðŸ“Š Feature Importance")
        feat_imp = pd.Series(model.feature_importances_, index=X.columns).sort_values(ascending=False).head(20)
        fig, ax = plt.subplots(figsize=(10, 6))
        sns.barplot(x=feat_imp.values, y=feat_imp.index, ax=ax)
        ax.set_title("Top 20 Feature Importances")
        st.pyplot(fig)

        # Confusion matrix
        st.subheader("ðŸ§ª Confusion Matrix")
        y_pred_all = model.predict(X)
        cm = confusion_matrix(y, y_pred_all, labels=model.classes_)
        cm_df = pd.DataFrame(cm, index=model.classes_, columns=model.classes_)
        fig2, ax2 = plt.subplots(figsize=(6, 5))
        sns.heatmap(cm_df, annot=True, fmt="d", cmap="Blues", ax=ax2)
        ax2.set_xlabel("Predicted")
        ax2.set_ylabel("Actual")
        ax2.set_title("Confusion Matrix")
        st.pyplot(fig2)

# -----------------------------
# 6. Single Sequence Prediction
# -----------------------------
st.subheader("ðŸ”¬ Predict Taste of a New Peptide")
user_seq = st.text_input("Enter peptide sequence (e.g., EDEGEQPRPF)")

if st.button("Predict"):
    if user_seq:
        feats = compute_features([user_seq])
        if not feats.empty:
            prediction = model.predict(feats)[0]
            probs = model.predict_proba(feats)[0]

            st.success(f"Predicted Taste: **{prediction}**")

            st.write("Class Probabilities:")
            prob_df = pd.DataFrame({"Taste Class": model.classes_, "Probability": probs})
            st.dataframe(prob_df)

            # Physicochemical properties
            st.subheader("ðŸ§ª Peptide Properties")
            props = compute_basic_properties(user_seq)
            if props:
                st.table(pd.DataFrame(list(props.items()), columns=["Property", "Value"]))

            # Structure
            st.subheader("ðŸ§¬ Predicted Peptide Structure")
            try:
                viewer = show_structure(user_seq)
                st.components.v1.html(viewer._make_html(), height=450)
            except Exception as e:
                st.warning(f"Could not generate structure: {e}")
        else:
            st.warning("Could not compute features for the entered sequence.")
    else:
        st.warning("Please enter a peptide sequence.")

# -----------------------------
# 7. Batch Prediction
# -----------------------------
st.subheader("ðŸ“¤ Batch Prediction from File")
uploaded = st.file_uploader("Upload a CSV or Excel file with a 'peptide' column")

if uploaded:
    if uploaded.name.endswith(".csv"):
        df_up = pd.read_csv(uploaded)
    else:
        df_up = pd.read_excel(uploaded)

    df_up.columns = df_up.columns.str.strip()

    if "peptide" not in df_up.columns:
        st.error("File must contain a 'peptide' column.")
    else:
        feats_up = compute_features(df_up["peptide"].tolist())
        if not feats_up.empty:
            preds = model.predict(feats_up)
            df_up["Predicted_Taste"] = preds
            st.write("Predictions:")
            st.dataframe(df_up)
            st.download_button(
                "Download Results",
                df_up.to_csv(index=False).encode(),
                file_name="predictions.csv",
                mime="text/csv"
            )
        else:
            st.error("Could not compute features for the uploaded sequences.")

    # -----------------------------
    # 6. Batch Prediction
    # -----------------------------
    st.subheader("ðŸ“¤ Batch Prediction from File")
    uploaded = st.file_uploader("Upload a CSV or Excel file with a 'peptide' column") # Updated column name

    if uploaded:
        if uploaded.name.endswith(".csv"):
            df_up = pd.read_csv(uploaded)
        else:
            df_up = pd.read_excel(uploaded)

        # Clean column names of uploaded file
        df_up.columns = df_up.columns.str.strip()

        if "peptide" not in df_up.columns: # Updated column name check
            st.error("File must contain a 'peptide' column.")
        else:
            feats_up = compute_features(df_up["peptide"].tolist()) # Updated column name
            if not feats_up.empty:
                preds = model.predict(feats_up)
                df_up["Predicted_Taste"] = preds
                st.write("Predictions:")
                st.dataframe(df_up)
                st.download_button(
                    "Download Results",
                    df_up.to_csv(index=False).encode(),
                    file_name="predictions.csv",
                    mime="text/csv"
                )
            else:
                 st.error("Could not compute features for the sequences in the uploaded file.")
